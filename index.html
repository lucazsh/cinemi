require('dotenv').config();
const axios = require('axios');
const express = require('express');
const http = require('http');
const { Server } = require('socket.io');
const multer = require('multer');
const path = require('path');
const fs = require('fs');
const cors = require('cors');
const session = require('express-session');
const passport = require('passport');
const GoogleStrategy = require('passport-google-oauth20').Strategy;
const FRONTEND_ORIGIN = process.env.FRONTEND_URL || 'https://lucazsh.github.io';
const TMDB_API_KEY = process.env.TMDB_API_KEY || '834a24b1cb360c280a61363b70c3d603';
const TMDB_BASE_URL = 'https://api.themoviedb.org/3';
const UPLOAD_DIR = path.join(__dirname, 'uploads');
if (!fs.existsSync(UPLOAD_DIR)) fs.mkdirSync(UPLOAD_DIR, { recursive: true });

const storage = multer.diskStorage({
  destination: (req, file, cb) => cb(null, UPLOAD_DIR),
  filename: (req, file, cb) => {
    const safe = Date.now() + '-' + Math.random().toString(36).slice(2, 8) + path.extname(file.originalname);
    cb(null, safe);
  }
});

const upload = multer({ storage });

const app = express();
app.set('trust proxy', 1);
const server = http.createServer(app);
const io = new Server(server, {
  cors: { 
    origin: process.env.FRONTEND_URL || 'https://lucazsh.github.io/cinemi/',
    methods: ['GET', 'POST'],
    credentials: true
  }
});

// Session setup MUST come FIRST
app.use(session({
  secret: process.env.SESSION_SECRET || 'your-secret-key-change-in-production',
  resave: false,
  saveUninitialized: false,
  proxy: true,
  cookie: { 
    secure: false,
    httpOnly: false, // Allow JavaScript to read the cookie
    maxAge: 7 * 24 * 60 * 60 * 1000,
    sameSite: 'none' // Allow cross-site cookies
  }
}));

// Passport MUST come after session
app.use(passport.initialize());
app.use(passport.session());

// CORS must come after session and passport
  app.use(cors({
    origin: FRONTEND_ORIGIN,
    credentials: true
  }));


app.use(express.json());
app.use('/uploads', express.static(UPLOAD_DIR));

// Store active sessions with user data
const activeSessions = new Map();

// Google OAuth Strategy
passport.use(new GoogleStrategy({
    clientID: process.env.GOOGLE_CLIENT_ID,
    clientSecret: process.env.GOOGLE_CLIENT_SECRET,
    callbackURL: `${process.env.PUBLIC_URL}/auth/google/callback`
  },
  (accessToken, refreshToken, profile, done) => {
    console.log('âœ… Google auth successful for:', profile.displayName);
    const user = {
      id: profile.id,
      displayName: profile.displayName,
      username: null,
      email: profile.emails[0].value,
      photoUrl: profile.photos[0].value
    };
    return done(null, user);
  }
));

passport.serializeUser((user, done) => {
  console.log('ðŸ“ Serializing user:', user.username);
  done(null, user);
});

passport.deserializeUser((user, done) => {
  console.log('ðŸ“– Deserializing user:', user.username);
  done(null, user);
});

// Auth routes
app.get('/auth/google', (req, res, next) => {
  // Store the temporary session ID in the state parameter
  const state = req.sessionID;
  passport.authenticate('google', {
    scope: ['profile', 'email'],
    state: state
  })(req, res, next);
});

app.get('/auth/google/callback',
  passport.authenticate('google', { failureRedirect: '/auth/failed' }),
  (req, res) => {
    console.log('ðŸŽ‰ Login successful! User:', req.user?.displayName);
    console.log('ðŸ” Session ID:', req.sessionID);
    
    if (req.user) {
      const existingUser = userTags.get(req.user.id);
      if (existingUser && existingUser.username) {
        req.user.username = existingUser.username;
      }
      
      if (req.user.photoUrl) {
        userProfiles.set(req.user.username || req.user.id, req.user.photoUrl);
      }
      
      const sessionToken = req.sessionID;
      activeSessions.set(sessionToken, {
        user: req.user,
        createdAt: Date.now()
      });
      
      console.log('ðŸ’¾ Session token created:', sessionToken);
    }
    
    res.redirect(`${FRONTEND_ORIGIN}/cinemi/?sessionToken=${req.sessionID}`);
  }
);

app.get('/auth/failed', (req, res) => {
  res.send('<h1>Login Failed</h1><a href="/">Go back</a>');
});

app.get('/auth/logout', (req, res) => {
  const sessionToken = req.headers['x-session-token'];
  
  if (sessionToken) {
    activeSessions.delete(sessionToken);
    console.log('ðŸ‘‹ Session removed:', sessionToken);
  }
  
  req.logout((err) => {
    if (err) {
      console.error('Logout error:', err);
      return res.status(500).json({ ok: false });
    }
    req.session.destroy((err) => {
      if (err) console.error('Session destroy error:', err);
      res.json({ ok: true });
    });
  });
});

app.get('/auth/user', (req, res) => {
  console.log('ðŸ” /auth/user called');
  
  // Check for session token in header or query
  const sessionToken = req.headers['x-session-token'] || req.query.sessionToken;
  
  console.log('ðŸ“¦ Session token:', sessionToken);
  
  if (sessionToken && activeSessions.has(sessionToken)) {
    const sessionData = activeSessions.get(sessionToken);
    console.log('âœ… Valid session found for:', sessionData.user.username);
    return res.json({ ok: true, user: sessionData.user });
  }
  
  // Fallback to regular session
  if (req.isAuthenticated()) {
    console.log('âœ… User authenticated via cookie:', req.user.username);
    return res.json({ ok: true, user: req.user });
  }
  
  console.log('âŒ No valid session found');
  res.json({ ok: false, user: null });
});

// Middleware to check authentication
function isAuthenticated(req, res, next) {
  const sessionToken = req.headers['x-session-token'];
  
  if (sessionToken && activeSessions.has(sessionToken)) {
    const sessionData = activeSessions.get(sessionToken);
    req.user = sessionData.user;
    console.log('ðŸ”’ Auth via token - User:', req.user.username);
    return next();
  }
  
  if (req.isAuthenticated()) {
    console.log('ðŸ”’ Auth via cookie - User:', req.user.username);
    return next();
  }
  
  res.status(401).json({ ok: false, error: 'Not authenticated' });
}

let posts = [];
let userProfiles = new Map();

let userTags = new Map();

function isUserTagTaken(tag) {
  return Array.from(userTags.values()).some(user => user.username === tag);
}

app.post('/auth/set-username', isAuthenticated, (req, res) => {
  const { username } = req.body;
  
  if (!username || username.trim().length < 3) {
    return res.status(400).json({ ok: false, error: 'Username must be at least 3 characters' });
  }

  const cleanUsername = username.trim().toLowerCase().replace(/[^a-z0-9_]/g, '');
  
  if (isUserTagTaken(cleanUsername)) {
    return res.status(409).json({ ok: false, error: 'Username already taken' });
  }

  const oldUsername = req.user.username;
  req.user.username = cleanUsername;
  userTags.set(req.user.id, req.user);
  
  posts.forEach(post => {
    if (post.username === oldUsername) post.username = cleanUsername;
    if (post.replies) {
      post.replies.forEach(reply => {
        if (reply.username === oldUsername) reply.username = cleanUsername;
      });
    }
  });

  res.json({ 
    ok: true, 
    username: cleanUsername,
    displayName: req.user.displayName
  });
});

app.get('/api/search/users', (req, res) => {
  const query = (req.query.q || '').toLowerCase();
  if (!query) return res.json([]);
  
  const results = Array.from(userTags.values())
    .filter(user => user.username.toLowerCase().includes(query))
    .slice(0, 10)
    .map(u => ({
      username: u.username,
      photoUrl: u.photoUrl || 'https://i.imgflip.com/1ickup.jpg'
    }));
  
  res.json(results);
});

function findPostById(id) {
  return posts.find(p => p.id === id);
}

app.get('/api/posts', (req, res) => {
  let filtered = posts.slice().reverse();
  if (req.query.since) {
    const since = parseInt(req.query.since);
    filtered = filtered.filter(p => new Date(p.createdAt).getTime() > since);
  }
  res.json(filtered);
});

app.post('/api/posts', isAuthenticated, upload.array('files', 6), (req, res) => {
  const username = req.user.username;
  const displayName = req.user.displayName;
  const text = (req.body.text || '').toString();
  const tempId = req.body.tempId;
  const photoUrl = req.user.photoUrl || 'https://i.imgflip.com/1ickup.jpg';

  const files = (req.files || []).map(f => ({
    originalName: f.originalname,
    mime: f.mimetype,
    url: `${getBaseUrl(req)}/uploads/${f.filename}`
  }));

  const post = {
    id: Date.now().toString(36) + '-' + Math.random().toString(36).slice(2, 6),
    username,
    displayName,
    text,
    photoUrl,
    files,
    replies: [],
    createdAt: new Date().toISOString()
  };

  if (tempId) post.tempId = tempId;
  posts.push(post);
  io.emit('post_created', post);
  res.json({ ok: true, post });
});

app.post('/api/posts/:postId/replies', isAuthenticated, (req, res) => {
  const postId = req.params.postId;
  const post = findPostById(postId);
  if (!post) return res.status(404).json({ ok: false, error: 'Post not found' });

  const username = req.user.username;
  const displayName = req.user.displayName;
  const text = (req.body.text || '').toString();
  if (!text.trim()) return res.status(400).json({ ok: false, error: 'Empty reply' });

  const photoUrl = req.user.photoUrl || 'https://i.imgflip.com/1ickup.jpg';

  const reply = {
    id: Date.now().toString(36) + '-' + Math.random().toString(36).slice(2, 6),
    postId,
    username,
    displayName,
    text,
    photoUrl,
    createdAt: new Date().toISOString()
  };

  post.replies = post.replies || [];
  post.replies.push(reply);
  io.emit('reply_created', reply);
  res.json({ ok: true, reply });
});
app.get('/api/posts/:postId/replies', (req, res) => {
  const postId = req.params.postId;
  const post = findPostById(postId);
  if (!post) {
    return res.status(404).json({ ok: false, error: 'Post not found' });
  }

  let replies = (post.replies || []).slice().sort((a, b) => 
    new Date(a.createdAt) - new Date(b.createdAt)
  );

  if (req.query.since) {
    const since = parseInt(req.query.since);
    if (!isNaN(since)) {
      replies = replies.filter(r => new Date(r.createdAt).getTime() > since);
    }
  }
  res.json(replies);
});

app.post('/api/profile/photo', isAuthenticated, upload.single('photo'), (req, res) => {
  try {
    if (!req.file) {
      return res.status(400).json({ ok: false, error: 'No file uploaded' });
    }

    const username = req.user.username;
    const photoUrl = `${getBaseUrl(req)}/uploads/${req.file.filename}`;
    userProfiles.set(username, photoUrl);

    req.user.photoUrl = photoUrl;
    
    posts.forEach(post => {
      if (post.username === username) post.photoUrl = photoUrl;
      if (post.replies) {
        post.replies.forEach(reply => {
          if (reply.username === username) reply.photoUrl = photoUrl;
        });
      }
    });

    io.emit('profile_updated', { username, photoUrl });
    res.json({ ok: true, photoUrl });
  } catch (err) {
    console.error('Profile photo upload error:', err);
    res.status(500).json({ ok: false, error: 'Upload failed' });
  }
});

app.get('/api/profile/photo/:username', (req, res) => {
  const username = req.params.username;
  const photoUrl = userProfiles.get(username);
  res.json({ 
    ok: true, 
    photoUrl: photoUrl || 'https://i.imgflip.com/1ickup.jpg' 
  });
});

function getBaseUrl(req) {
  if (process.env.PUBLIC_URL) return process.env.PUBLIC_URL.replace(/\/$/, '');
  return `${req.protocol}://${req.get('host')}`;
}

io.on('connection', (socket) => {
  console.log('Socket connected:', socket.id);
  socket.on('disconnect', () => console.log('Socket disconnected:', socket.id));
});

app.get('/api/tmdb/search/movie', async (req, res) => {
  try {
    const query = req.query.query;
    if (!query) {
      return res.status(400).json({ error: 'Query parameter required' });
    }

    const response = await axios.get(`${TMDB_BASE_URL}/search/movie`, {
      params: {
        api_key: TMDB_API_KEY,
        query: query
      }
    });

    res.json(response.data);
  } catch (error) {
    console.error('TMDB search error:', error);
    res.status(500).json({ error: 'Failed to fetch movies' });
  }
});

// Proxy endpoint pentru watch providers
app.get('/api/tmdb/movie/:id/watch/providers', async (req, res) => {
  try {
    const movieId = req.params.id;
    
    const response = await axios.get(`${TMDB_BASE_URL}/movie/${movieId}/watch/providers`, {
      params: {
        api_key: TMDB_API_KEY
      }
    });

    res.json(response.data);
  } catch (error) {
    console.error('TMDB providers error:', error);
    res.status(500).json({ error: 'Failed to fetch providers' });
  }
});

// Proxy endpoint pentru movie details (optional, pentru viitor)
app.get('/api/tmdb/movie/:id', async (req, res) => {
  try {
    const movieId = req.params.id;
    
    const response = await axios.get(`${TMDB_BASE_URL}/movie/${movieId}`, {
      params: {
        api_key: TMDB_API_KEY
      }
    });

    res.json(response.data);
  } catch (error) {
    console.error('TMDB details error:', error);
    res.status(500).json({ error: 'Failed to fetch movie details' });
  }
});

// Clean up old sessions (older than 7 days)
setInterval(() => {
  const now = Date.now();
  const sevenDays = 7 * 24 * 60 * 60 * 1000;
  
  for (const [token, data] of activeSessions.entries()) {
    if (now - data.createdAt > sevenDays) {
      activeSessions.delete(token);
      console.log('ðŸ§¹ Cleaned up old session:', token);
    }
  }
}, 60 * 60 * 1000); // Check every hour

const PORT = process.env.PORT || 3000;
server.listen(PORT, () => console.log(`Server listening on port ${PORT}`));
